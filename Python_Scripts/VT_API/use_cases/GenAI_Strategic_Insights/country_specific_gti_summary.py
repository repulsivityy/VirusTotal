"""
This script fetches threat intelligence reports from Google Threat Intelligence (GTI) via API, 
uses Google's Gemini AI model to generate a country-specific threat summary, 
and prints the result to the console.

Code runs a dual pass method to generate a threat intelligence summary:
1. Generate a narrative summary using Gemini AI.
2. Extracts CVEs from the summary, fetch their details, and append a vulnerability table to the report.

It is a conversion of a Jupyter Notebook to a standalone Python script.

Version: 2.2 (Added country filter to the API query for more relevant results)

Usage: python3 country_specific_gti_summary.py

Arguments:
    -c, --country: The country to focus the report on (default: Singapore).
    -l, --language: The output language for the summary (default: English).
    -d, --days: The number of days back to fetch reports from (default: 4).
    --enrich-cve: Enable this flag to fetch and include summaries for CVEs mentioned in the reports (default: True).
    -m, --model: The Gemini model to use for the summary (default: gemini-1.5-flash).

Environment Variables Required:
    - GTI_APIKEY: Your Google Threat Intelligence API key.
    - GEMINI_APIKEY: Your Google AI Studio API key for Gemini.
"""

import os
import re
import asyncio
import datetime
from tqdm import tqdm
import aiohttp
import json
import argparse

####################
#  Configuration and Initialization 
####################

def parse_arguments():

    parser = argparse.ArgumentParser(
        description="Generate a country-specific threat intelligence summary using GTI and Gemini."
    )
    parser.add_argument(
        "-c", "--country",
        type=str,
        default="Singapore",
        help="The country to focus the report on (e.g., 'Germany'). Default: Singapore."
    )
    parser.add_argument(
        "-l", "--language",
        type=str,
        default="English",
        help="The output language for the summary (e.g., 'German'). Default: English."
    )
    parser.add_argument(
        "-d", "--days",
        type=int,
        default=5,
        help="The number of days back to fetch reports from. Default: 4."
    )
    parser.add_argument(
       "--enrich-cve",
        action=argparse.BooleanOptionalAction,
        default=True,
        help="Enable this flag to fetch and include summaries for CVEs mentioned in the reports."
    )
    parser.add_argument(
        "-m", "--model",
        type=str,
        default="gemini-1.5-flash",
        choices=["gemini-1.5-flash", "gemini-1.5-pro"],
        help="The Gemini model to use for the summary. Default: gemini-1.5-flash."
    )
    return parser.parse_args()

def load_env_vars():
    gti_api_key = os.getenv("GTI_APIKEY")
    gemini_api_key = os.getenv("GEMINI_APIKEY")

    if not all([gti_api_key, gemini_api_key]):
        raise ValueError(
            "Missing required environment variables. "
            "Please set GTI_APIKEY and GEMINI_APIKEY in your environment."
        )
    
    print("Environment variables loaded successfully.")
    return gti_api_key, gemini_api_key

####################
#  Data Fetching and Parsing
####################

def parse_report_from_api(report_data):
    #Parses a report dictionary from the GTI API JSON response.
    
    attrs = report_data.get('attributes', {})
    creation_timestamp = attrs.get('creation_date')
    
    creation_date_str = datetime.datetime.fromtimestamp(creation_timestamp).isoformat() if creation_timestamp else ''
    report_id = report_data.get('id', '')

    # Construct the user-friendly GUI link instead of using the API self-link because the original linked to the API response
    gui_link = f"https://www.virustotal.com/gui/collection/{report_id}" if report_id else ""

    return {
        'report_id': report_id,
        'name': attrs.get('name', ''),
        'collection_type': attrs.get('collection_type', ''),
        'origin': attrs.get('origin', ''),
        'creation_date': creation_date_str,
        'autogenerated_summary': attrs.get('autogenerated_summary', ''),
        'executive_summary': attrs.get('executive_summary', ''),
        'content': attrs.get('content', ''),
        'report_type': attrs.get('report_type', ''),
        'link': gui_link
    }

def extract_cves_from_reports(collections):
    """
    Extracts all unique CVE identifiers from the fetched reports or a block of text.
    
    Args:
        collections (list or str): A list of report dictionaries or a string of text.

    Returns:
        set: A set of unique CVE strings found.
    """
    cve_pattern = re.compile(r'CVE-\d{4}-\d{4,7}', re.IGNORECASE)
    # The input can now be a list of reports or a single string (the AI summary)
    text_to_search = json.dumps(collections) if isinstance(collections, (list, dict)) else collections
    found_cves = set(cve_pattern.findall(text_to_search))
    
    if found_cves and isinstance(collections, list):
        print(f"✅ Found {len(found_cves)} unique CVEs to enrich.")
    
    return found_cves

def parse_vulnerability_from_api(cve_id, vuln_data):
    # Extracts vul data from GTI 
    try:
        attributes = vuln_data.get('data', {}).get('attributes', {})
        cvss_data = attributes.get('cvss', {})
        cwe_data = attributes.get('cwe', {})
        cisa_kev_data = attributes.get('cisa_known_exploited', {})

        # Check if the CVE is in CISA's KEV catalog
        is_in_kev = "Yes" if cisa_kev_data and cisa_kev_data.get('added_date') else "No"

        return {
            "cve_id": cve_id.upper(),
            "name": attributes.get('name', cve_id.upper()),
            "risk_rating": attributes.get('risk_rating', 'N/A'),
            "cwe_title": cwe_data.get('title', 'N/A'),
            "cvss_v4_score": cvss_data.get('cvssv4_x', {}).get('score', 'N/A'),
            "cisa_kev": is_in_kev,
            "description_for_vendor": attributes.get('description', ''),
            "sources_for_vendor": attributes.get('sources', [])
        }
    except (KeyError, TypeError):
        print(f"Could not parse data for {cve_id.upper()}. Response format might be different.")
        return None

async def fetch_vulnerability_details(session, gti_api_key, cves):
    # Fetches details for a list of CVEs from GTI

    headers = {'x-apikey': gti_api_key, 'x-tool': 'AI Content Generation'}
    
    async def fetch_single_cve(cve_id):
        # The API endpoint uses the format: vulnerability--cve-xxxx-yyyyy
        collection_id = f"vulnerability--{cve_id.lower()}" # to matech collection id format
        url = f"https://www.virustotal.com/api/v3/collections/{collection_id}"
        try:
            async with session.get(url, headers=headers) as response:
                if response.status == 200:
                    data = await response.json()
                    return parse_vulnerability_from_api(cve_id, data)
                elif response.status == 404:
                    print(f"ℹ️  CVE {cve_id.upper()} not found in Google Threat Intelligence.")
                    return None
                else:
                    print(f"⚠️  Error fetching {cve_id.upper()}: Status {response.status}")
                    return None
        except Exception as e:
            print(f"An error occurred fetching {cve_id.upper()}: {e}")
            return None

    tasks = [fetch_single_cve(cve) for cve in cves]
    
    results = []
    for task in tqdm(asyncio.as_completed(tasks), total=len(tasks), desc="Fetching CVE Details"):
        result = await task
        if result:
            results.append(result)

    if results:
         print(f"✅ Successfully enriched {len(results)} of {len(cves)} CVEs.")
    else:
        print("No CVE details could be fetched.")

    return results

async def fetch_reports(session, gti_api_key, country, start_date='4d', end_date='0d', limit=1000):

    print(f"Fetching reports from {start_date} ago to {end_date} ago for {country}...")
    
    base_url = 'https://www.virustotal.com/api/v3/collections'
    headers = {'x-apikey': gti_api_key, 'x-tool': 'AI Content Summarisation'}
    params = {
        "filter": f"collection_type:report target_country:{country} NOT origin:'Google Threat Intelligence' creation_date:{start_date}+ creation_date:{end_date}-",
        "order": "creation_date-",
        "limit": 40
    }

    collections = []
    next_url = base_url

    with tqdm(total=limit, desc="Fetching GTI Reports") as pbar:
        while next_url and len(collections) < limit:
            async with session.get(next_url, headers=headers, params=params) as response:
                if params:
                    params = None
                
                response.raise_for_status()
                data = await response.json()
                
                fetched_data = data.get('data', [])
                parsed_reports = [parse_report_from_api(item) for item in fetched_data]
                
                num_to_add = min(len(parsed_reports), limit - len(collections))
                collections.extend(parsed_reports[:num_to_add])
                pbar.update(num_to_add)

                next_url = data.get('links', {}).get('next') if len(collections) < limit else None

    print(f"✅ Fetched {len(collections)} reports.")
    return collections

####################
#  Gemini System Prompt
####################

def get_system_instruction(output_country, output_language):

    return f"""
    <PROMPT>
        <ROLE>
            You are a highly sophisticated AI simulating a skilled writer with the combined expertise of a **seasoned Threat Intelligence Analyst** and a **meticulous News Editor**. You have a keen ability to identify and summarize threat landscape developments with specific relevance to a particular country and communicate them clearly in the local language. Your writing is authoritative, concise, accurate, and engaging.
        </ROLE>

        <TASK>
            Generate a **compelling, concise, and engaging weekly threat intelligence newsletter** focused on the most important landscape developments relevant to the specified {output_country}. You must filter provided reports for relevance, select the top stories, and summarize them accurately in {output_language}. The output format must be followed precisely.
        </TASK>

        <CONTEXT>
            This newsletter serves as a key intelligence touchpoint for customers and security professionals operating in the {output_country}. It offers a curated, easy-to-digest summary of the most critical OSINT developments impacting their security posture. The goal is to provide actionable or contextually significant intelligence tailored to their specific region.
        </CONTEXT>

        <INPUT_FORMAT>
            1.  **`TARGET_COUNTRY`:** The specific country the newsletter should focus on (e.g., "Brazil," "Germany," "Japan").
            2.  **`TARGET_LANGUAGE`:** The language for the final output (e.g., "Portuguese," "German," "Japanese").
            3.  **`REPORT_OBJECTS`:** A list of intelligence report objects, primarily with `Origin` of 'Crowdsourced' or 'Partner', but may also include 'News Analysis' reports for perspective. Each object may contain fields such as:
                * `content`: Text of the report/summary.
                * `link`: URL to the source.
                * `report_id` (for any `origin:Google Threat Intelligence` reports).
                * `date`: Publication or update date.
        </INPUT_FORMAT>

        <PROCESSING_INSTRUCTIONS>
           1.  **Read & Filter for Country Relevance:**
            * Analyze all provided `REPORT_OBJECTS`.
            * Create a shortlist of reports that have **direct relevance** to organizations, government entities, or individuals in {output_country}. This includes threats originating from, targeting, or having specific industry or geopolitical implications for that country.

        2.  **Select & Synthesize for the Newsletter:**
            * From your country-relevant shortlist, select the **top 8-10 most significant stories**.
            * Prioritize stories involving: 1) Widely exploited vulnerabilities impacting the country, 2) Major intrusions against entities in the country, 3) Cyber attacks with real-world local consequences, or 4) Notable shifts in the regional threat landscape.
            * For each selected story, write a concise summary (2-4 sentences).
            * **Include CVEs in Headlines:** If a story revolves around a specific vulnerability or vulnerabilities, ensure the CVE identifier (e.g., CVE-2024-12345) is mentioned prominently in the bold title or the first sentence of the summary. This is critical for the vulnerability enrichment step that happens *after* you generate the text.
            * **GTI Perspective:** If any `origin:Google Threat Intelligence` 'News Analysis' reports are available on these topics, incorporate or reference that perspective to add value.
            * **Link Source:** Ensure each summary includes an inline link to the primary OSINT source report using its `link` field. Prioritize media sources based in the same region as the {output_country}.

        3.  **Translate to Target Language:**
            * Ensure the entire final output, including all headings and summaries, is written fluently and accurately in {output_language}.
        </PROCESSING_INSTRUCTIONS>

        <OUTPUT_FORMAT>
            Generate the briefing in Markdown, adhering strictly to the following structure and translating all static text (headings, greetings) into the **`TARGET_LANGUAGE`**.

            1.  **Date:** Start with the full date (e.g., `Tuesday, April 15, 2025`).
            2.  **Title:** Add a bold title on the next line: `**Google Threat Intelligence Update for {output_language}**` (Translated).
            3.  **Greeting:** Add a simple, professional greeting (Translated).
            4.  **Summary Paragraph:** Write a brief (2-4 sentence) introductory paragraph highlighting the 1-2 most important developments covered below, based *only* on selected items (Translated).
            5.  **Section:** Include a single main section, for example: `**Key Threat Landscape Developments**` (Translated).
            6.  **List Items:** Within the main section, list the 8-10 individual story summaries using Markdown bullet points (`* `).
                * Start each item with a bold title/phrase summarizing the story (Translated).
                * Provide a concise (2-4 sentences) description of the development, including its specific relevance to **`{output_country}`**.
                * Embed a relevant Markdown link *within* the description text: `[Descriptive Text](URL)`. Hyperlink 3-5 contextually relevant words. The URL should come from the OSINT report's `link` field.
                * If you reference a GTI perspective from a 'News Analysis' report, you may also include a link to it using its `report_id`.
        </OUTPUT_FORMAT>
        
        <CONSTRAINTS>
        * **Country Focus:** All selected stories MUST be relevant to `{output_country}`.
            * **Language:** The final output MUST be entirely in `{output_language}`.
            * **Item Count:** The newsletter should contain **8-10** story summaries.
            * **No CVE Table:** Do NOT generate a "Vulnerability Spotlight" table. This will be added later by the program. Focus only on writing the narrative summary.
            * **Recency:** Prioritize information from the last 24-48 hours for a daily brief, or the last week for a weekly brief.
            * **Linking:** Use *only* inline Markdown links. Every item must have at least one functional link to a source.
            * **Accuracy:** Report facts accurately based on the provided inputs. Do not hallucinate.
            * **No Sub-bullets:** Do not use nested bullet points within a summary item.
        </CONSTRAINTS>
    </PROMPT>
    """

####################
#  User Prompt Creation
####################

def get_user_prompt(collections, output_country, cve_details=None):
    """
    Creates the user-facing prompt that includes the fetched report data and optional CVE data.
    """
    today_str = datetime.date.today().strftime("%A, %B %d, %Y")
    
    collections_subset = collections[:350] # Limit to the first 300 reports to avoid exceeding token limits. Number can be adjusted based on testing.
    
    total_length = len(str(collections_subset))
    est_tokens = total_length / 4
    print(f"Truncated collection to {len(collections_subset)} reports.")
    print(f"Estimated tokens for Gemini prompt: {int(est_tokens)}")

    prompt = f"""
    Create a concise and engaging newsletter for cyber threat intelligence professionals protecting organizations and interests based in {output_country}.
    Use the following reports as source material.
    Begin each item in the newsletter summary (before the bold title) with a thematically appropriate emoji, following the bullet point. No duplicates; each item must have a unique emoji.
    Use Bold text for the section headers; do not use H2 headers.
    Select items with an eye to your {output_country} readership.
    Make sure you highlight concerns that would be relevant to {output_country} security professionals.

    Today's date is {today_str}

    REPORT_OBJECTS: {collections_subset}
    """
    # cve_details not needed, but keeping this for potential future use as I got lazy to remove it
    if cve_details:
        prompt += f"\n\nVULNERABILITY_DETAILS: {cve_details}"

    prompt += "\n\nOutput:"
    return prompt

async def generate_summary(session, api_key, model_name, system_instruction, user_prompt):
    # Generates the threat intelligence summary using the Gemini API directly.
    print("Generating summary with Gemini API...")
    
    api_url = f"https://generativelanguage.googleapis.com/v1beta/models/{model_name}:generateContent?key={api_key}"
    
    headers = {"Content-Type": "application/json"}

    payload = {
        "contents": [{"role": "user", "parts": [{"text": user_prompt}]}],
        "systemInstruction": {"parts": [{"text": system_instruction}]},
        "generationConfig": {
            "temperature": 0.6,
            "topP": 0.95,
            "topK": 64,
            "candidateCount": 1,
            "stopSequences": ["STOP!"],
        }
    }

    async with session.post(api_url, headers=headers, data=json.dumps(payload)) as response:
        response.raise_for_status()
        result = await response.json()
        
        try:
            summary = result['candidates'][0]['content']['parts'][0]['text']
            print("✅ Summary generated.")
            return summary
        except (KeyError, IndexError) as e:
            print(f"Error parsing Gemini response: {e}")
            print(f"Full response: {result}")
            raise

####################
#  CVE Table Generation
####################

def create_vulnerability_table(cve_details, output_language):
    # A more robust solution for translation could use a proper library, maybe google translate or similar lib? 
    # For now, we default to English.
    title = "Vulnerability Spotlight"

    # Example of simple translation
    if output_language.lower() == 'german':
        title = "Schwachstellen-Spotlight"

    # table creates a Markdown table with CVE details
    table_lines = [f"**{title}**"]
    table_lines.append("| CVE | Name | Vendor | CVSSv4 Score | Risk Rating | CWE Title | CISA KEV |")
    table_lines.append("|---|---|---|---|---|---|---|")
    
    for cve in cve_details:
        vendor = "TBD"
        row = (
            f"| {cve.get('cve_id', 'N/A')} "
            f"| {cve.get('name', 'N/A')} "
            f"| {vendor} "
            f"| {cve.get('cvss_v4_score', 'N/A')} "
            f"| {cve.get('risk_rating', 'N/A')} "
            f"| {cve.get('cwe_title', 'N/A')} "
            f"| {cve.get('cisa_kev', 'N/A')} |"
        )
        table_lines.append(row)
        
    return "\n".join(table_lines)

async def main():

    args = parse_arguments()
    
    output_country = args.country
    output_language = args.language
    start_date = f"{args.days}d"
    gemini_model_name = args.model
    

    try:
        gti_api_key, gemini_api_key = load_env_vars()
        
        async with aiohttp.ClientSession() as session:
            ### PASS 1: Generate Narrative Summary ###
            collections = await fetch_reports(session, gti_api_key, output_country, start_date=start_date)
            
            if not collections:
                print("No reports found. Exiting.")
                return
            
            # Create prompts for the first pass (narrative only)
            system_instruction = get_system_instruction(output_country, output_language)
            user_prompt = get_user_prompt(collections, output_country, cve_details=None)
            
            # Generate the base summary text
            summary_text = await generate_summary(
                session, gemini_api_key, gemini_model_name, system_instruction, user_prompt
            )
            
            # The final report starts with the AI-generated summary
            final_report = summary_text

            ### PASS 2: Extract, Enrich, and Append CVEs ###
            if args.enrich_cve:
                # Extract CVEs directly from the AI's generated text
                cves_from_summary = extract_cves_from_reports(summary_text)
                
                if cves_from_summary:
                    print(f"✅ Extracted {len(cves_from_summary)} CVEs from the summary for enrichment.")
                    
                    # Fetch details for relevant CVEs
                    cve_details = await fetch_vulnerability_details(session, gti_api_key, cves_from_summary)
                    
                    if cve_details:
                        # Programmatically create the Markdown table
                        vulnerability_table = create_vulnerability_table(cve_details, output_language)
                        # Append the table to the final report
                        final_report += "\n\n" + vulnerability_table
                else:
                    print("ℹ️ No CVEs found in the generated summary to enrich.")

            ### Final Output ###
            print("\n" + "="*80)
            print(f"Threat Intelligence Summary for {output_country}")
            print("="*80 + "\n")
            print(final_report)

    except aiohttp.ClientResponseError as e:
        print(f"API Error: {e.status} - {e.message}")
        print("Please check your API keys and the request payload size.")
    except Exception as e:
        print(f"An unexpected error occurred: {e}")

if __name__ == "__main__":
    asyncio.run(main())

