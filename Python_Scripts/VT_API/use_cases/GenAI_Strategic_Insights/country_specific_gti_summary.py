
"""
This script fetches threat intelligence reports from Google Threat Intelligence (GTI) via API, 
uses Google's Gemini AI model to generate a country-specific threat summary, 
and prints the result to the console.

It is a conversion of a Jupyter Notebook to a standalone Python script.
Version: 1.1 
"""

import os
import re
import asyncio
import datetime
from tqdm import tqdm
import aiohttp
import json
import argparse

####################
#  Configuration and Initialization 
####################

def parse_arguments():
    """
    Parses command-line arguments for the script.
    """
    parser = argparse.ArgumentParser(
        description="Generate a country-specific threat intelligence summary using GTI and Gemini."
    )
    parser.add_argument(
        "-c", "--country",
        type=str,
        default="Singapore",
        help="The country to focus the report on (e.g., 'Germany'). Default: Singapore."
    )
    parser.add_argument(
        "-l", "--language",
        type=str,
        default="English",
        help="The output language for the summary (e.g., 'German'). Default: English."
    )
    parser.add_argument(
        "-d", "--days",
        type=int,
        default=5,
        help="The number of days back to fetch reports from. Default: 4."
    )
    parser.add_argument(
       "--enrich-cve",
        action=argparse.BooleanOptionalAction,
        default=True,
        help="Enable this flag to fetch and include summaries for CVEs mentioned in the reports."
    )
    parser.add_argument(
        "-m", "--model",
        type=str,
        default="gemini-2.5-flash",
        choices=["gemini-2.5-flash", "gemini-2.5-pro"],
        help="The Gemini model to use for the summary. Default: gemini-2.5-flash."
    )
    return parser.parse_args()

def load_env_vars():
    """
    Loads environment variables directly from the OS.
    
    Environment Variables Required:
        - GTI_APIKEY: Your Google Threat Intelligence (Google Threat Intelligence) API key.
        - GEMINI_APIKEY: Your Google AI Studio API key for Gemini.
    
    Returns:
        tuple: A tuple containing the GTI API key and the Gemini API key.
    """
    gti_api_key = os.getenv("GTI_APIKEY")
    gemini_api_key = os.getenv("GEMINI_APIKEY")

    if not all([gti_api_key, gemini_api_key]):
        raise ValueError(
            "Missing required environment variables. "
            "Please set GTI_APIKEY and GEMINI_APIKEY in your environment."
        )
    
    print("✅ Environment variables loaded successfully.")
    return gti_api_key, gemini_api_key

####################
#  Data Fetching and Parsing
####################

def parse_report_from_api(report_data):
    """
    Parses a report dictionary from the GTI API JSON response.
    
    Args:
        report_data (dict): A single report item from the 'data' array of the GTI API response.

    Returns:
        dict: A dictionary containing key attributes from the report.
    """
    attrs = report_data.get('attributes', {})
    creation_timestamp = attrs.get('creation_date')
    
    creation_date_str = datetime.datetime.fromtimestamp(creation_timestamp).isoformat() if creation_timestamp else ''

    return {
        'report_id': report_data.get('id', ''),
        'name': attrs.get('name', ''),
        'collection_type': attrs.get('collection_type', ''),
        'origin': attrs.get('origin', ''),
        'creation_date': creation_date_str,
        'autogenerated_summary': attrs.get('autogenerated_summary', ''),
        'executive_summary': attrs.get('executive_summary', ''),
        'content': attrs.get('content', ''),
        'report_type': attrs.get('report_type', ''),
        'link': report_data.get('links', {}).get('self', '').replace('/api/v3/', '/')
    }

def extract_cves_from_reports(collections):
    """
    Extracts all unique CVE identifiers from the fetched reports.
    
    Args:
        collections (list): A list of report dictionaries.

    Returns:
        set: A set of unique CVE strings found in the reports.
    """
    cve_pattern = re.compile(r'CVE-\d{4}-\d{4,7}', re.IGNORECASE)
    all_text = json.dumps(collections)
    found_cves = set(cve_pattern.findall(all_text))
    
    if found_cves:
        print(f"✅ Found {len(found_cves)} unique CVEs to enrich.")
    
    return found_cves

def parse_vulnerability_from_api(cve_id, vuln_data):
    """
    Parses the JSON response from the GTI vulnerabilities endpoint to extract detailed information.
    
    Args:
        cve_id (str): The CVE identifier (e.g., 'CVE-2025-8610').
        vuln_data (dict): The JSON data from the API response for a single vulnerability.

    Returns:
        dict: A dictionary containing the parsed CVE details for the AI prompt.
    """
    try:
        attributes = vuln_data.get('data', {}).get('attributes', {})
        cvss_data = attributes.get('cvss', {})
        cwe_data = attributes.get('cwe', {})
        cisa_kev_data = attributes.get('cisa_known_exploited', {})

        # Check if the CVE is in CISA's KEV catalog
        is_in_kev = "Yes" if cisa_kev_data and cisa_kev_data.get('added_date') else "No"

        return {
            "cve_id": cve_id.upper(),
            "name": attributes.get('name', cve_id.upper()),
            "risk_rating": attributes.get('risk_rating', 'N/A'),
            "cwe_title": cwe_data.get('title', 'N/A'),
            "cvss_v4_score": cvss_data.get('cvssv4_x', {}).get('score', 'N/A'),
            "cisa_kev": is_in_kev,
            # Provide raw data for the AI to determine the vendor
            "description_for_vendor": attributes.get('description', ''),
            "sources_for_vendor": attributes.get('sources', [])
        }
    except (KeyError, TypeError):
        print(f"Could not parse data for {cve_id.upper()}. Response format might be different.")
        return None

async def fetch_vulnerability_details(session, gti_api_key, cves):
    """
    Fetches details for a list of CVEs from the Google Threat Intelligence vulnerabilities endpoint.
    
    Args:
        session (aiohttp.ClientSession): The aiohttp session for making requests.
        gti_api_key (str): The Google Threat Intelligence API key.
        cves (set): A set of CVE IDs to fetch details for.

    Returns:
        list: A list of dictionaries, each containing details for a CVE.
    """
    headers = {'x-apikey': gti_api_key, 'x-tool': 'AI Content Generation'}
    
    async def fetch_single_cve(cve_id):
        # The API endpoint uses the format: vulnerability--cve-xxxx-yyyyy
        collection_id = f"vulnerability--{cve_id.lower()}"
        url = f"https://www.virustotal.com/api/v3/collections/{collection_id}"
        try:
            async with session.get(url, headers=headers) as response:
                if response.status == 200:
                    data = await response.json()
                    return parse_vulnerability_from_api(cve_id, data)
                elif response.status == 404:
                    print(f"ℹ️  CVE {cve_id.upper()} not found in Google Threat Intelligence.")
                    return None
                else:
                    print(f"⚠️  Error fetching {cve_id.upper()}: Status {response.status}")
                    return None
        except Exception as e:
            print(f"An error occurred fetching {cve_id.upper()}: {e}")
            return None

    tasks = [fetch_single_cve(cve) for cve in cves]
    
    results = []
    for task in tqdm(asyncio.as_completed(tasks), total=len(tasks), desc="Fetching CVE Details"):
        result = await task
        if result:
            results.append(result)

    if results:
         print(f"✅ Successfully enriched {len(results)} of {len(cves)} CVEs.")
    else:
        print("No CVE details could be fetched.")

    return results

async def fetch_reports(session, gti_api_key, start_date='4d', end_date='0d', limit=1000):
    """
    Fetches threat intelligence reports from the Google Threat Intelligence API based on a date range.
    """
    print(f"Fetching reports from {start_date} ago to {end_date} ago...")
    
    base_url = 'https://www.virustotal.com/api/v3/collections'
    headers = {'x-apikey': gti_api_key, 'x-tool': 'AI Content Generation'}
    params = {
        "filter": f"collection_type:report NOT origin:'Google Threat Intelligence' creation_date:{start_date}+ creation_date:{end_date}-",
        "order": "creation_date-",
        "limit": 40
    }

    collections = []
    next_url = base_url

    with tqdm(total=limit, desc="Fetching GTI Reports") as pbar:
        while next_url and len(collections) < limit:
            async with session.get(next_url, headers=headers, params=params) as response:
                if params:
                    params = None
                
                response.raise_for_status()
                data = await response.json()
                
                fetched_data = data.get('data', [])
                parsed_reports = [parse_report_from_api(item) for item in fetched_data]
                
                num_to_add = min(len(parsed_reports), limit - len(collections))
                collections.extend(parsed_reports[:num_to_add])
                pbar.update(num_to_add)

                next_url = data.get('links', {}).get('next') if len(collections) < limit else None

    print(f"✅ Fetched {len(collections)} reports.")
    return collections

####################
#  Gemini System Prompt
####################

def get_system_instruction(output_country, output_language):
    """
    Creates the detailed system instruction prompt for the Gemini model.
    """
    return f"""
    <PROMPT>
        <ROLE>
            You are a highly sophisticated AI simulating a skilled writer with the combined expertise of a **seasoned Threat Intelligence Analyst** and a **meticulous News Editor**. You have a keen ability to identify and summarize threat landscape developments with specific relevance to a particular country and communicate them clearly in the local language. Your writing is authoritative, concise, accurate, and engaging.
        </ROLE>

        <TASK>
            Generate a **compelling, concise, and engaging weekly threat intelligence newsletter** focused on the most important landscape developments relevant to the specified {output_country}. You must filter provided reports for relevance, select the top stories, summarize them accurately in {output_language}, and format the output precisely as defined. If vulnerability data is provided, you must also include a CVE summary table at the end.
        </TASK>

        <CONTEXT>
            <!-- Context: Emphasizes the newsletter's value for a specific regional audience. -->
            This newsletter serves as a key intelligence touchpoint for customers and security professionals operating in the {output_country}. It offers a curated, easy-to-digest summary of the most critical OSINT developments impacting their security posture. The goal is to provide actionable or contextually significant intelligence tailored to their specific region.
        </CONTEXT>

        <INPUT_FORMAT>
            <!-- Input: Now includes country and language parameters. -->
            1.  **`TARGET_COUNTRY`:** The specific country the newsletter should focus on (e.g., "Brazil," "Germany," "Japan").
            2.  **`TARGET_LANGUAGE`:** The language for the final output (e.g., "Portuguese," "German," "Japanese").
            3.  **`REPORT_OBJECTS`:** A list of intelligence report objects, primarily with `Origin` of 'Crowdsourced' or 'Partner', but may also include 'News Analysis' reports for perspective. Each object may contain fields such as:
                *   `content`: Text of the report/summary.
                *   `link`: URL to the source.
                *   `report_id` (for any `origin:Google Threat Intelligence` reports).
                *   `date`: Publication or update date.
        </INPUT_FORMAT>

        <PROCESSING_INSTRUCTIONS>
           1.  **Read & Filter for Country Relevance:**
            *   Analyze all provided `REPORT_OBJECTS`.
            *   Create a shortlist of reports that have **direct relevance** to organizations, government entities, or individuals in {output_country}. This includes threats originating from, targeting, or having specific industry or geopolitical implications for that country.

        2.  **Select & Synthesize for the Newsletter:**
            *   From your country-relevant shortlist, select the **top 8-10 most significant stories**.
            *   Prioritize stories involving: 1) Widely exploited vulnerabilities impacting the country, 2) Major intrusions against entities in the country, 3) Cyber attacks with real-world local consequences, or 4) Notable shifts in the regional threat landscape.
            *   For each selected story, write a concise summary (2-4 sentences).
            *   **Include CVEs in Headlines:** If a story revolves around a specific vulnerability or vulnerabilities, ensure the CVE identifier (e.g., CVE-2024-12345) is mentioned prominently in the bold title or the first sentence of the summary. This is critical for the vulnerability enrichment step.
            *   **GTI Perspective:** If any `origin:Google Threat Intelligence` 'News Analysis' reports are available on these topics, incorporate or reference that perspective to add value.
            *   **Link Source:** Ensure each summary includes an inline link to the primary OSINT source report using its `link` field. Prioritize media sources based in the same region as the {output_country}.

        3.  **Vulnerability Summary (If Applicable):** 
            * If a `VULNERABILITY_DETAILS` object is provided, you must create a section at the end of the report titled "**Vulnerability Spotlight**" (translated to `{output_language}`).
            * This section must contain a table that summarizes the key details for each CVE mentioned in the reports. The table should look similar to the example below.
            * You are responsible for extracting the vendor from the `description_for_vendor` and `sources_for_vendor` fields and populating the rest of the table from the provided data.

        4.  **Translate to Target Language:**
            *   Ensure the entire final output, including all headings and summaries, is written fluently and accurately in {output_language}.
        </PROCESSING_INSTRUCTIONS>

        <EXAMPLE>
            **Vulnerability Spotlight**
            | CVE | Name | Vendor | CVSSv4 Score | Risk Rating | CWE Title | CISA KEV |
            |---|---|---|---|---|---|---|
            | CVE-2024-4577 | PHP Remote Code Execution Vulnerability | PHP Group | 9.8 | Critical | CWE-22: Path Traversal | No |
            | CVE-2024-8610 | Authentication Bypass in a WordPress Plugin | WordPress.org | 7.5 | High | CWE-287: Improper Authentication | No |
        </EXAMPLE>

        <OUTPUT_FORMAT>
            <!-- Output Format: Simplified structure with a dynamic title. -->
            Generate the briefing in Markdown, adhering strictly to the following structure and translating all static text (headings, greetings) into the **`TARGET_LANGUAGE`**.

            1.  **Date:** Start with the full date (e.g., `Tuesday, April 15, 2025`).
            2.  **Title:** Add a bold title on the next line: `**Google Threat Intelligence Update for {output_language}**` (Translated).
            3.  **Greeting:** Add a simple, professional greeting (Translated).
            4.  **Summary Paragraph:** Write a brief (2-4 sentence) introductory paragraph highlighting the 1-2 most important developments covered below, based *only* on selected items (Translated).
            5.  **Section:** Include a single main section, for example: `**Key Threat Landscape Developments**` (Translated).
            6.  **List Items:** Within the main section, list the 8-10 individual story summaries using Markdown bullet points (`* `).
                *   Start each item with a bold title/phrase summarizing the story (Translated).
                *   Provide a concise (2-4 sentences) description of the development, including its specific relevance to **`{output_country}`**.
                *   Embed a relevant Markdown link *within* the description text: `[Descriptive Text](URL)`. Hyperlink 3-5 contextually relevant words. The URL should come from the OSINT report's `link` field.
                *   If you reference a GTI perspective from a 'News Analysis' report, you may also include a link to it using its `report_id`.
            7.  **Vulnerabilities:** If any vulnerabilities are seen within the reports, add a section titled `**Vulnerability Spotlight**` (Translated). 
        </OUTPUT_FORMAT>

        <STYLE_GUIDELINES>
        <!-- Style: Emphasizes country relevance and native-level fluency. -->
            *   **Language & Tone:** The entire output must be in fluent, professional **`{output_country}`**. Maintain an authoritative, objective, and concise tone appropriate for security professionals in that country.
            * **CVE Inclusion:** When a story is about a vulnerability, the corresponding CVE-ID must be present in the summary text to facilitate further analysis and linking.
            *   **Country Relevance:** **Every single item** included must clearly state or imply its relevance to the **`{output_country}`**. This is the primary value of the newsletter.
            *   **Style:** Be direct, factual, and engaging.
            *   **GTI Attribution:** Use appropriate phrasing (in the `{output_language}`) to attribute any perspectives from `origin:Google Threat Intelligence` analysis.
        </STYLE_GUIDELINES>

        <CONSTRAINTS>
        <!-- Constraints: Updated to reflect the new structure and focus. -->
            *   **Country Focus:** All selected stories MUST be relevant to `{output_country}`.
            *   **Language:** The final output MUST be entirely in `{output_language}`.
            *   **Item Count:** The newsletter should contain **8-10** story summaries.
            *   **Section Structure:** The newsletter must NOT contain `From the Frontlines` or `In the News` sections. It should have one primary content section.
            *   **Recency:** Prioritize information from the last 24-48 hours for a daily brief, or the last week for a weekly brief.
            *   **Linking:** Use *only* inline Markdown links. Every item must have at least one functional link to a source.
            *   **Accuracy:** Report facts accurately based on the provided inputs. Do not hallucinate.
            *   **No Sub-bullets:** Do not use nested bullet points within a summary item.
        </CONSTRAINTS>
    </PROMPT>
    """

####################
#  User Prompt Creation
####################

def get_user_prompt(collections, output_country, cve_details=None):
    """
    Creates the user-facing prompt that includes the fetched report data and optional CVE data.
    """
    today_str = datetime.date.today().strftime("%A, %B %d, %Y")
    
    collections_subset = collections[:300] # Limit to the first 300 reports to avoid exceeding token limits. Number can be adjusted based on testing.
    
    total_length = len(str(collections_subset))
    est_tokens = total_length / 4
    print(f"Truncated collection to {len(collections_subset)} reports.")
    print(f"Estimated tokens for Gemini prompt: {int(est_tokens)}")

    prompt = f"""
    Create a concise, engaging newsletter for cyber threat intelligence professionals protecting organizations and interests based in {output_country}.
    Use the following reports as source material.
    Begin each item in the newsletter summary (before the bold title) with a thematically appropriate emoji, following the bullet point. No duplicates; each item must have a unique emoji.
    Use Bold text for the section headers; do not use H2 headers.
    Select items with an eye to your {output_country} readership.
    Make sure you highlight concerns that would be relevant to {output_country} security professionals.

    Today's date is {today_str}

    REPORT_OBJECTS: {collections_subset}
    """

    if cve_details:
        prompt += f"\n\nVULNERABILITY_DETAILS: {cve_details}"

    prompt += "\n\nOutput:"
    return prompt

async def generate_summary(session, api_key, model_name, system_instruction, user_prompt):
    """
    Generates the threat intelligence summary using the Gemini API directly.
    """
    print("Generating summary with Gemini API...")
    
    api_url = f"https://generativelanguage.googleapis.com/v1beta/models/{model_name}:generateContent?key={api_key}"
    
    headers = {"Content-Type": "application/json"}

    payload = {
        "contents": [{"role": "user", "parts": [{"text": user_prompt}]}],
        "systemInstruction": {"parts": [{"text": system_instruction}]},
        "generationConfig": {
            "temperature": 0.6,
            "topP": 0.95,
            "topK": 64,
            "candidateCount": 1,
            "stopSequences": ["STOP!"],
        }
    }

    async with session.post(api_url, headers=headers, data=json.dumps(payload)) as response:
        response.raise_for_status()
        result = await response.json()
        
        try:
            summary = result['candidates'][0]['content']['parts'][0]['text']
            print("✅ Summary generated.")
            return summary
        except (KeyError, IndexError) as e:
            print(f"Error parsing Gemini response: {e}")
            print(f"Full response: {result}")
            raise


async def main():
    """
    The main function to run the threat intelligence summary generation process.
    """
    args = parse_arguments()
    
    output_country = args.country
    output_language = args.language
    start_date = f"{args.days}d"
    gemini_model_name = args.model
    
    try:
        gti_api_key, gemini_api_key = load_env_vars()
        
        async with aiohttp.ClientSession() as session:
            collections = await fetch_reports(session, gti_api_key, start_date=start_date)
            
            if not collections:
                print("No reports found. Exiting.")
                return
            
            cve_details = None
            if args.enrich_cve:
                cves = extract_cves_from_reports(collections)
                if cves:
                    cve_details = await fetch_vulnerability_details(session, gti_api_key, cves)
            
            system_instruction = get_system_instruction(output_country, output_language)
            user_prompt = get_user_prompt(collections, output_country, cve_details)
            
            summary_text = await generate_summary(
                session, gemini_api_key, gemini_model_name, system_instruction, user_prompt
            )
            
            print("\n" + "="*80)
            print(f"Threat Intelligence Summary for {output_country}")
            print("="*80 + "\n")
            print(summary_text)

    except aiohttp.ClientResponseError as e:
        print(f"API Error: {e.status} - {e.message}")
        print("Please check your API keys and the request payload size.")
    except Exception as e:
        print(f"An unexpected error occurred: {e}")

if __name__ == "__main__":
    asyncio.run(main())