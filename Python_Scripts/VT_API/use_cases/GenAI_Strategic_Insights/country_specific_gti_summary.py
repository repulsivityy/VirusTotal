"""
This script fetches threat intelligence reports from Google Threat Intel (GTI) via API, 
uses Google's Gemini AI model to generate a country-specific threat summary, 
and prints the result to the console.
"""

import os
import asyncio
import datetime
from tqdm import tqdm
import aiohttp
import json

# --- Configuration and Initialization ---

def load_env_vars():
    """
    Loads environment variables directly from the OS.
    
    Environment Variables Required:
        - GTI_APIKEY: Your VirusTotal (Google Threat Intelligence) API key.
        - GEMINI_APIKEY: Your Google AI Studio API key for Gemini.
    
    Returns:
        tuple: A tuple containing the GTI API key and the Gemini API key.
    """
    gti_api_key = os.getenv("GTI_APIKEY")
    gemini_api_key = os.getenv("GEMINI_APIKEY")

    if not all([gti_api_key, gemini_api_key]):
        raise ValueError(
            "Missing required environment variables. "
            "Please set GTI_APIKEY and GEMINI_APIKEY in your environment."
        )
    
    print("✅ Environment variables loaded successfully.")
    return gti_api_key, gemini_api_key

# --- Data Fetching and Parsing ---

def parse_report_from_api(report_data):
    """
    Parses a report dictionary from the VT API JSON response.
    
    Args:
        report_data (dict): A single report item from the 'data' array of the VT API response.

    Returns:
        dict: A dictionary containing key attributes from the report.
    """
    attrs = report_data.get('attributes', {})
    creation_timestamp = attrs.get('creation_date')
    
    # Convert timestamp to ISO 8601 format string if it exists
    creation_date_str = datetime.datetime.fromtimestamp(creation_timestamp).isoformat() if creation_timestamp else ''

    return {
        'report_id': report_data.get('id', ''),
        'name': attrs.get('name', ''),
        'collection_type': attrs.get('collection_type', ''),
        'origin': attrs.get('origin', ''),
        'creation_date': creation_date_str,
        'autogenerated_summary': attrs.get('autogenerated_summary', ''),
        'executive_summary': attrs.get('executive_summary', ''),
        'content': attrs.get('content', ''),
        'report_type': attrs.get('report_type', ''),
        'link': report_data.get('links', {}).get('self', '').replace('/api/v3/', '/')
    }

async def fetch_reports(session, gti_api_key, start_date='2d', end_date='0d', limit=1000):
    """
    Fetches threat intelligence reports from the VirusTotal API based on a date range.

    Args:
        session (aiohttp.ClientSession): The aiohttp session for making requests.
        gti_api_key (str): The VirusTotal API key.
        start_date (str): The start date for the report search (e.g., '4d' for 4 days ago).
        end_date (str): The end date for the report search (e.g., '0d' for today).
        limit (int): The maximum number of reports to fetch.

    Returns:
        list: A list of dictionaries, where each dictionary is a parsed report.
    """
    print(f"Fetching reports from {start_date} ago to {end_date} ago...")
    
    base_url = 'https://www.virustotal.com/api/v3/collections'
    headers = {'x-apikey': gti_api_key, 'x-tool': 'AI Content Generation'}
    # Parameters are only used for the very first request
    params = {
        "filter": f"collection_type:report NOT origin:'Google Threat Intelligence' creation_date:{start_date}+ creation_date:{end_date}-",
        "order": "creation_date-",
        "limit": 40  # Max limit per request is 40
    }

    collections = []
    next_url = base_url

    with tqdm(total=limit, desc="Fetching VT Reports") as pbar:
        while next_url and len(collections) < limit:
            async with session.get(next_url, headers=headers, params=params) as response:
                # Clear params after the first request as the `next_url` contains them
                if params:
                    params = None
                
                response.raise_for_status()
                data = await response.json()
                
                fetched_data = data.get('data', [])
                parsed_reports = [parse_report_from_api(item) for item in fetched_data]
                
                # Ensure we don't exceed the overall limit
                num_to_add = min(len(parsed_reports), limit - len(collections))
                collections.extend(parsed_reports[:num_to_add])
                pbar.update(num_to_add)

                # Check for the next page
                next_url = data.get('links', {}).get('next') if len(collections) < limit else None

    print(f"✅ Fetched {len(collections)} reports.")
    return collections

# --- AI Content Generation ---

def get_system_instruction(output_country, output_language):
    """
    Creates the detailed system instruction prompt for the Gemini model.
    """
    return f"""
    <PROMPT>
        <ROLE>
            You are a highly sophisticated AI simulating a skilled writer with the combined expertise of a **seasoned Threat Intelligence Analyst** and a **meticulous News Editor**. You have a keen ability to identify and summarize threat landscape developments with specific relevance to a particular country and communicate them clearly in the local language.
        </ROLE>
        <TASK>
            Generate a **compelling, concise, and engaging weekly threat intelligence newsletter** focused on the most important landscape developments relevant to the specified {output_country}. You must filter provided reports for relevance, select the top stories, summarize them accurately in {output_language}, and format the output precisely as defined.
        </TASK>
        <PROCESSING_INSTRUCTIONS>
            1.  **Filter for Country Relevance:** Analyze all provided `REPORT_OBJECTS` and create a shortlist of reports with **direct relevance** to organizations, government entities, or individuals in {output_country}.
            2.  **Select & Synthesize:** From your shortlist, select the **top 8-10 most significant stories**. Write a concise summary (2-4 sentences) for each. Ensure each summary includes an inline link to the source report.
            3.  **Translate:** Ensure the entire final output is written fluently and accurately in {output_language}.
        </PROCESSING_INSTRUCTIONS>
        <OUTPUT_FORMAT>
            Generate the briefing in Markdown, translating all static text (headings, greetings) into the **`TARGET_LANGUAGE`**.
            1.  **Date:** Start with the full date (e.g., `Tuesday, April 15, 2025`).
            2.  **Title:** Add a bold title: `**Google Threat Intelligence Update for {output_country}**` (Translated).
            3.  **Summary Paragraph:** Write a brief introductory paragraph highlighting the 1-2 most important developments.
            4.  **Section:** Include one main section: `**Key Threat Landscape Developments**` (Translated).
            5.  **List Items:** List the 8-10 summaries using Markdown bullet points (`* `). Start each item with a bold title/phrase. Embed a relevant Markdown link *within* the description text: `[Descriptive Text](URL)`.
        </OUTPUT_FORMAT>
        <CONSTRAINTS>
            * All stories MUST be relevant to `{output_country}`.
            * The final output MUST be entirely in `{output_language}`.
            * The newsletter should contain **8-10** summaries.
            * Use *only* inline Markdown links.
            * Do not hallucinate; base all information on the provided reports.
        </CONSTRAINTS>
    </PROMPT>
    """

def get_user_prompt(collections, output_country):
    """
    Creates the user-facing prompt that includes the fetched report data.
    """
    today_str = datetime.date.today().strftime("%A, %B %d, %Y")
    
    # *** FIX: Truncate the collections to a reasonable size to avoid API errors ***
    # Let's take the most recent 100 reports as a sample
    collections_subset = collections[:100]
    
    total_length = len(str(collections_subset))
    est_tokens = total_length / 4
    print(f"Truncated collection to {len(collections_subset)} reports.")
    print(f"Estimated tokens for Gemini prompt: {int(est_tokens)}")

    return f"""
    Create a concise, engaging newsletter for cyber threat intelligence professionals protecting organizations and interests based in {output_country}.
    Use the following reports as source material.
    Begin each item in the newsletter summary (before the bold title) with a thematically appropriate emoji, following the bullet point. No duplicates; each item must have a unique emoji.
    Use Bold text for the section headers.
    Select items with an eye to your {output_country} readership.
    Make sure you highlight concerns that would be relevant to {output_country} security professionals.

    Today's date is {today_str}

    Input: {collections_subset}

    Output:
    """

async def generate_summary(session, api_key, model_name, system_instruction, user_prompt):
    """
    Generates the threat intelligence summary using the Gemini API directly.

    Args:
        session (aiohttp.ClientSession): The aiohttp session for making requests.
        api_key (str): Your API key for the Gemini API.
        model_name (str): The name of the Gemini model to use (e.g., 'gemini-1.5-pro-latest').
        system_instruction (str): The system prompt defining the AI's role and task.
        user_prompt (str): The user prompt containing the report data.

    Returns:
        str: The generated text summary from the AI model.
    """
    print("Generating summary with Gemini API...")
    
    api_url = f"https://generativelanguage.googleapis.com/v1beta/models/{model_name}:generateContent?key={api_key}"
    
    headers = {"Content-Type": "application/json"}

    payload = {
        "contents": [{"role": "user", "parts": [{"text": user_prompt}]}],
        "systemInstruction": {"parts": [{"text": system_instruction}]},
        "generationConfig": {
            "temperature": 0.6,
            "topP": 0.95,
            "topK": 64,
            "candidateCount": 1,
            "stopSequences": ["STOP!"],
        }
    }

    async with session.post(api_url, headers=headers, data=json.dumps(payload)) as response:
        response.raise_for_status()
        result = await response.json()
        
        try:
            summary = result['candidates'][0]['content']['parts'][0]['text']
            print("✅ Summary generated.")
            return summary
        except (KeyError, IndexError) as e:
            print(f"Error parsing Gemini response: {e}")
            print(f"Full response: {result}")
            raise

# --- Main Execution ---

async def main():
    """
    The main function to run the threat intelligence summary generation process.
    """
    # --- Parameters ---
    output_country = "Korea"
    output_language = "Korean" 
    gemini_model_name = "gemini-2.5-flash-preview-05-20" # Use the specified flash model
    # --- End Parameters ---

    try:
        gti_api_key, gemini_api_key = load_env_vars()
        
        # Use a single session for all API calls
        async with aiohttp.ClientSession() as session:
            # 1. Fetch reports from VT API
            collections = await fetch_reports(session, gti_api_key)
            
            if not collections:
                print("No reports found. Exiting.")
                return
                
            # 2. Prepare prompts for Gemini
            system_instruction = get_system_instruction(output_country, output_language)
            user_prompt = get_user_prompt(collections, output_country)
            
            # 3. Generate the summary via Gemini API
            summary_text = await generate_summary(
                session, gemini_api_key, gemini_model_name, system_instruction, user_prompt
            )
            
            # 4. Print the final result
            print("\n" + "="*80)
            print(f"Threat Intelligence Summary for {output_country}")
            print("="*80 + "\n")
            print(summary_text)

    except aiohttp.ClientResponseError as e:
        print(f"API Error: {e.status} - {e.message}")
        print("Please check your API keys and the request payload size.")
    except Exception as e:
        print(f"An unexpected error occurred: {e}")

if __name__ == "__main__":
    asyncio.run(main())



